// Copyright 2024, University of Colorado Boulder

/**
 * The PDLStopwatchNode represents the stopwatch node for the Projectile Data Lab. It is like a normal stopwatch node,
 * but with an additional Launch button that is used to launch the projectile and start the stopwatch at the same time.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import projectileDataLab from '../../projectileDataLab.js';
import StopwatchNode, { StopwatchNodeOptions } from '../../../../scenery-phet/js/StopwatchNode.js';
import RectangularPushButton from '../../../../sun/js/buttons/RectangularPushButton.js';
import ProjectileDataLabStrings from '../../ProjectileDataLabStrings.js';
import Stopwatch from '../../../../scenery-phet/js/Stopwatch.js';
import optionize from '../../../../phet-core/js/optionize.js';
import WithRequired from '../../../../phet-core/js/types/WithRequired.js';
import PDLText from '../../common/view/PDLText.js';
import DerivedStringProperty from '../../../../axon/js/DerivedStringProperty.js';
import TReadOnlyProperty from '../../../../axon/js/TReadOnlyProperty.js';
import DerivedProperty from '../../../../axon/js/DerivedProperty.js';
import PDLPreferences from '../../common/PDLPreferences.js';

type SelfOptions = {
  launchButtonEnabledProperty: TReadOnlyProperty<boolean>;
};
type PDLStopwatchNodeOptions = SelfOptions & WithRequired<StopwatchNodeOptions, 'tandem'>;

export default class PDLStopwatchNode extends StopwatchNode {
  public constructor( stopwatch: Stopwatch, launchProjectile: () => void, providedOptions: PDLStopwatchNodeOptions ) {

    const labelProperty = new DerivedStringProperty( [ ProjectileDataLabStrings.stopStringProperty, ProjectileDataLabStrings.launchStringProperty, stopwatch.isRunningProperty ], ( stopString, launchString, isRunning ) => {
      return isRunning ? stopString : launchString;
    } );

    // The button toggles between "Launch" and "Stop". When launching, the timer starts automatically.
    const launchStopButton = new RectangularPushButton( {

      // Fire the button on down, so that the user can time the launch in a similar way to a real stopwatch
      fireOnDown: true,
      baseColor: 'lightgray',

      // Disable the button when all projectiles have been exhausted, but always allow the user to stop the stopwatch
      enabledProperty: DerivedProperty.or( [ providedOptions.launchButtonEnabledProperty, stopwatch.isRunningProperty ] ),

      content: new PDLText( labelProperty, {
        maxWidth: 50
      } ),
      layoutOptions: {
        stretch: true,
        xMargin: 6.3
      },
      tandem: providedOptions.tandem.createTandem( 'launchStopButton' ),
      listener: () => {
        stopwatch.isRunningProperty.value = !stopwatch.isRunningProperty.value;

        if ( stopwatch.isRunningProperty.value ) {
          stopwatch.timeProperty.reset();
          launchProjectile();
        }
      },
      soundPlayer: {

        // Don't compete with the launch sound or the landing sound
        stop: _.noop,
        play: _.noop
      },
      touchAreaXDilation: 3,
      touchAreaYDilation: 3
    } );

    const options = optionize<PDLStopwatchNodeOptions, SelfOptions, StopwatchNodeOptions>()( {
      visibleProperty: new DerivedProperty( [ stopwatch.isVisibleProperty, PDLPreferences.autoGenerateDataProperty ],
        ( stopwatchIsVisible, autoGenerateData ) => stopwatchIsVisible && !autoGenerateData ),
      includePlayPauseResetButtons: false,
      otherControls: [ launchStopButton ]
    }, providedOptions );

    super( stopwatch, options );
  }
}
projectileDataLab.register( 'PDLStopwatchNode', PDLStopwatchNode );